#!/usr/bin/env bash
#
# Simple scaffolding helper for Python modules in the monorepo.
#
# Usage:
#   ./scaffolding/scaffold_python.sh <module_name>
#
# The script materialises a Bazel‑compatible Python package under
# `python/<module_name>` following the same layout generated by the
# `python_cookiecutter` template.
#
# Notes:
# * We intentionally avoid a hard dependency on the `cookiecutter` CLI to
#   keep the bootstrap experience lightweight (see PRD §Cost Efficiency).
# * Place‑holder substitution is performed with `sed` which is available in
#   both GNU and BSD flavours. We detect the platform to choose the correct
#   in‑place flag syntax.
#
set -euo pipefail

if [[ $# -ne 1 ]]; then
  echo "Usage: $0 <module_name>" >&2
  exit 1
fi

NAME=$1
DEST_DIR="python/${NAME}"

# Ensure destination does not already exist to prevent accidental overwrite.
if [[ -e "${DEST_DIR}" ]]; then
  echo "Error: directory ${DEST_DIR} already exists" >&2
  exit 1
fi

TEMPLATE_DIR="scaffolding/python_cookiecutter/{{cookiecutter.module_name}}"

# Copy template skeleton then perform placeholder substitution.
cp -R "${TEMPLATE_DIR}" "${DEST_DIR}"

# Rename the primary files to the requested module name.
mv "${DEST_DIR}/{{cookiecutter.module_name}}.py" "${DEST_DIR}/${NAME}.py"

# Helper function: portable in‑place sed (BSD vs GNU).
function sed_inplace() {
  local pattern="$1" file="$2"
  if sed --version >/dev/null 2>&1; then
    # GNU sed
    sed -i -e "${pattern}" "$file"
  else
    # BSD / macOS sed
    sed -i '' -e "${pattern}" "$file"
  fi
}

# Replace placeholders in all files under destination directory.
for f in $(find "${DEST_DIR}" -type f); do
  sed_inplace "s/{{cookiecutter.module_name}}/${NAME}/g" "$f"
done

echo "Created Python module ${NAME}"
